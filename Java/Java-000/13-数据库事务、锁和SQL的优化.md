1. Mysql事务与锁
 - 事务可靠性模型ACID
    * Atomicity: 原子性, 一次事务中的操作要么全部成功, 要么全部失败。 
    * Consistency: 一致性, 跨表、跨行、跨事务, 数据库始终保持一致状态。比如保证了原子性，但是多次操作导致了问题。
    * Isolation: 隔离性, 可见性, 保护事务不会互相干扰, 包含4种隔离级别。 
    * Durability:, 持久性, 事务提交成功后,不会丢数据。如电源故障, 系统崩溃。
 - InnoDB 非常多的机制
    * 双写缓冲区、故障恢复、操作系统、fsync() 、磁盘存储、缓存、UPS、网络、备份策略 …… 
 - Mysql的锁
    * 表级锁
        + 意向锁: 表明事务稍后要进行哪种类型的锁定
        + 共享意向锁(IS): 打算在某些行上设置共享锁
        + 排他意向锁(IX): 打算对某些行设置排他锁,如select xxxx for update;
        + Insert 意向锁: Insert 操作设置的间隙锁
        + 其他 
            - 自增锁(AUTO-IN)
            - LOCK TABLES/DDL 
    * 行级锁(InnoDB)
        + 记录锁(Record): 始终锁定索引记录，注意隐藏的聚簇索引;
        + 间隙锁(Gap):
        + 临键锁(Next-Key): 记录锁+间隙锁的组合; 可“锁定”表中不存在记录
        + 谓词锁(Predicat): 空间索引
    * 死锁
        + 阻塞与互相等待
        + 增删改、锁定读
        + 死锁检测与自动回滚
        + 锁粒度与程序设计
 - 事务隔离级别，就是在并发的时候，可以容忍什么样的不一致性。为了提供性能，降低
    * 读未提交: READ UNCOMMITTED---类似于HashMap，没有什么锁定
        + 很少使用
        + 不能保证一致性
        + 脏读(dirty read) : 使用到从未被确认的数 据(例如: 早期版本、回滚)
        + 以非锁定方式执行
        + 可能的问题: 脏读、幻读、不可重复读
    * 读已提交: READ COMMITTED---看到的数据都是别的线程已经提交过---多次读的数据可能是不一样的
        + 每次查询都会设置和读取自己的新快照。
        + 仅支持基于行的 bin-log
        + 不可重复读: 不加锁的情况下, 其他事务 UPDATE 或 DELETE 会对查询结果有影响
        + 幻读(Phantom): 加锁后, 不锁定间隙, 其他事务可以 INSERT。
        + 锁定索引记录, 而不锁定记录之间的间隙
        + 可能的问题: 幻读、不可重复读
    * 可重复读: REPEATABLE READ---就是可以多次读，保证一致
        + InnoDB 的默认隔离级别
        + 使用事务第一次读取时创建的快照(核心)
        + 多版本技术
        + 使用唯一索引的唯一查询条件时, 只锁定查找到的索引记录, 不锁定间隙。
        + 其他查询条件, 会锁定扫描到的索引范围, 通过间隙锁或临键锁来阻止其他会话在这个
          范围中插入值。
        + 可能的问题: InnoDB 不能保证没有幻读, 需要加锁 
    * 可串行化: SERIALIZABLE---性能最差，基本就是串行化
 - MySQL的隔离级别:
    * 可以设置全局的默认隔离级别，默认是可重复读
    * 可以单独设置会话的隔离级别
    * InnoDB 实现与标准之间的差异   
 - undo log: 撤消日志
    * 保证事务的原子性
    * 用处: 事务回滚, 一致性读、崩溃恢复。
    * 记录事务回滚时所需的撤消操作
    * 一条 INSERT 语句，对应一条 DELETE 的 undo log
    * 每个 UPDATE 语句，对应一条相反 UPDATE 的 undo log
 - redo log：重做日志
    * 确保事务的持久性，防止事务提交后数据未刷新到磁盘就掉电或崩溃。
    * 事务执行过程中写入 redo log,记录事务对数据页做了哪些修改。
    * 提升性能: WAL(Write-Ahead Logging) 技术, 先写日志, 再写磁盘。
    * 日志文件: ib_logfile0, ib_logfile1
    * 日志缓冲: innodb_log_buffer_size
    * 强刷: fsync()
 - MVCC: 多版本并发控制
    * 使 InnoDB 支持一致性读: READ COMMITTED 和 REPEATABLE READ 。 
    * 让查询不被阻塞、无需等待被其他事务持有的锁，这种技术手段可以增加并发性能。
    * InnoDB 保留被修改行的旧版本。
    * 查询正在被其他事务更新的数据时，会读取更新之前的版本。
    * 每行数据都存在一个版本号, 每次更新时都更新该版本
    * 这种技术在数据库领域的使用并不普遍。 某些数据库, 以及某些 MySQL 存储引擎都不支持。
 - MVCC 实现机制
    * 隐藏列
    * 事务链表，保存还未提交的事务，事务提交则会从链表中摘除
    * Read view: 每个 SQL 一个, 包括 rw_trx_ids, low_limit_id, up_limit_id, low_limit_no 等 
    * 回滚段: 通过 undo log 动态构建旧版本数据   
 - 数据库死锁的两个办法
    * 超时
    * 强杀
    